// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define AbstractClassInfo(TYPE, PARENT) Entity::ClassInfo TYPE::m_sClass(#TYPE, &PARENT::m_sClass);
#define ConcreteClassInfo(TYPE, PARENT, BLOCKCOUNT) Entity::ClassInfo TYPE::m_sClass(#TYPE, &PARENT::m_sClass, TYPE::Allocate, TYPE::Deallocate, TYPE::NewInstance, BLOCKCOUNT);
#define ClassInfoGetters const Entity::ClassInfo & GetClass() const { return m_sClass; } const std::string & GetClassName() const { return m_sClass.GetName(); }
#define EntityAllocation(TYPE) static void * operator new (size_t size) { return TYPE::m_sClass.GetPoolMemory(); } static void operator delete (void *instance) { TYPE::m_sClass.ReturnPoolMemory(instance); } static void * operator new (size_t size, void *p) throw() { return p; } static void operator delete (void *, void *) throw() { } static void * Allocate() { return malloc(sizeof(TYPE)); } static void Deallocate(void *instance) { free(instance); } static Entity * NewInstance() { return new TYPE; } Entity * Clone(Entity *cloneTo = nullptr) const override { TYPE *ent = cloneTo ? dynamic_cast<TYPE *>(cloneTo) : new TYPE(); RTEAssert(ent, "Tried to clone to an incompatible instance!"); if (cloneTo) { ent->Destroy(); } ent->Create(*this); return ent; }
#define ScriptFunctionNames(...) virtual std::vector<std::string> GetSupportedScriptFunctionNames() const { return {__VA_ARGS__}; }
#define AddScriptFunctionNames(PARENT, ...) std::vector<std::string> GetSupportedScriptFunctionNames() const override { std::vector<std::string> functionNames = PARENT::GetSupportedScriptFunctionNames(); functionNames.insert(functionNames.end(), {__VA_ARGS__}); return functionNames; }
#define SerializableOverrideMethods int ReadProperty(const std::string_view &propName, Reader &reader) override; int Save(Writer &writer) const override;
#define SerializableClassNameGetter const std::string & GetClassName() const override { return c_ClassName; }
#define LuaBindingRegisterFunctionDeclarationForType(TYPENAME) static luabind::scope Register##TYPENAME##LuaBindings();
#define LuaBindingRegisterFunctionDefinitionForType(OWNINGSCOPENAME, TYPENAME) luabind::scope OWNINGSCOPENAME##::Register##TYPENAME##LuaBindings()
#define AbstractTypeLuaClassDefinition(TYPE, PARENTTYPE) luabind::class_<TYPE, PARENTTYPE>(#TYPE) .property("ClassName", &TYPE::GetClassName)
#define ConcreteTypeLuaClassDefinition(TYPE, PARENTTYPE) luabind::class_<TYPE, PARENTTYPE>(#TYPE) .def("Clone", &LuaAdaptersEntityClone::Clone##TYPE, luabind::adopt(luabind::result)) .property("ClassName", &TYPE::GetClassName)
#define RegisterLuaBindingsOfAbstractType(OWNINGSCOPE, TYPE) luabind::def((std::string("To") + std::string(#TYPE)).c_str(), (TYPE *(*)(Entity *))&LuaAdaptersEntityCast::To##TYPE), luabind::def((std::string("To") + std::string(#TYPE)).c_str(), (const TYPE *(*)(const Entity *))&LuaAdaptersEntityCast::ToConst##TYPE),	OWNINGSCOPE::Register##TYPE##LuaBindings()
#define RegisterLuaBindingsOfConcreteType(OWNINGSCOPE, TYPE) luabind::def((std::string("Create") + std::string(#TYPE)).c_str(), (TYPE *(*)(std::string, std::string))&LuaAdaptersEntityCreate::Create##TYPE, luabind::adopt(luabind::result)), luabind::def((std::string("Create") + std::string(#TYPE)).c_str(), (TYPE *(*)(std::string))&LuaAdaptersEntityCreate::Create##TYPE, luabind::adopt(luabind::result)), luabind::def((std::string("Random") + std::string(#TYPE)).c_str(), (TYPE *(*)(std::string, int))&LuaAdaptersEntityCreate::Random##TYPE, luabind::adopt(luabind::result)), luabind::def((std::string("Random") + std::string(#TYPE)).c_str(), (TYPE *(*)(std::string, std::string))&LuaAdaptersEntityCreate::Random##TYPE, luabind::adopt(luabind::result)), luabind::def((std::string("Random") + std::string(#TYPE)).c_str(), (TYPE *(*)(std::string))&LuaAdaptersEntityCreate::Random##TYPE, luabind::adopt(luabind::result)), luabind::def((std::string("To") + std::string(#TYPE)).c_str(), (TYPE *(*)(Entity *))&LuaAdaptersEntityCast::To##TYPE), luabind::def((std::string("To") + std::string(#TYPE)).c_str(), (const TYPE *(*)(const Entity *))&LuaAdaptersEntityCast::ToConst##TYPE), luabind::def((std::string("Is") + std::string(#TYPE)).c_str(), (bool(*)(const Entity *))&LuaAdaptersEntityCast::Is##TYPE), OWNINGSCOPE::Register##TYPE##LuaBindings()
#define RegisterLuaBindingsOfType(OWNINGSCOPE, TYPE) OWNINGSCOPE::Register##TYPE##LuaBindings()
#define DefaultPieMenuNameVirtual(DEFAULTPIEMENUNAME) virtual std::string GetDefaultPieMenuName() const { return DEFAULTPIEMENUNAME; }
#define DefaultPieMenuName(DEFAULTPIEMENUNAME) std::string GetDefaultPieMenuName() const override { return DEFAULTPIEMENUNAME; }
#define LuaEntityCreateFunctionsDeclarationsForType(TYPE) static TYPE * Create##TYPE(std::string preseName, std::string moduleName); static TYPE * Create##TYPE(std::string preset); static TYPE * Random##TYPE(std::string groupName, int moduleSpaceID); static TYPE * Random##TYPE(std::string groupName, std::string dataModuleName); static TYPE * Random##TYPE(std::string groupName)
#define LuaEntityCloneFunctionDeclarationForType(TYPE) static TYPE * Clone##TYPE(const TYPE *thisEntity)
#define LuaEntityCastFunctionsDeclarationsForType(TYPE) static TYPE * To##TYPE(Entity *entity); static const TYPE * ToConst##TYPE(const Entity *entity); static bool Is##TYPE(Entity *entity); static SolObjectWrapper * ToSolObject##TYPE(Entity *entity, lua_State *luaState)
#define LuaPropertyOwnershipSafetyFakerFunctionDeclaration(OBJECTTYPE, PROPERTYTYPE, SETTERFUNCTION) static void OBJECTTYPE##SETTERFUNCTION(OBJECTTYPE *luaSelfObject, PROPERTYTYPE *objectToSet)
#define LuaEntityCreateFunctionsDefinitionsForType(TYPE) TYPE * LuaAdaptersEntityCreate::Create##TYPE(std::string preseName, std::string moduleName) { const Entity *entityPreset = g_PresetMan.GetEntityPreset(#TYPE, preseName, moduleName); if (!entityPreset) { g_ConsoleMan.PrintString(std::string("ERROR: There is no ") + std::string(#TYPE) + std::string(" of the Preset name \"") + preseName + std::string("\" defined in the \"") + moduleName + std::string("\" Data Module!")); return nullptr; } return dynamic_cast<TYPE *>(entityPreset->Clone()); } TYPE * LuaAdaptersEntityCreate::Create##TYPE(std::string preset) { return Create##TYPE(preset, "All"); } TYPE * LuaAdaptersEntityCreate::Random##TYPE(std::string groupName, int moduleSpaceID) { const Entity *entityPreset = g_PresetMan.GetRandomBuyableOfGroupFromTech(groupName, #TYPE, moduleSpaceID); if (!entityPreset) { entityPreset = g_PresetMan.GetRandomBuyableOfGroupFromTech(groupName, #TYPE, g_PresetMan.GetModuleID("Base.rte")); } if (!entityPreset) { entityPreset = g_PresetMan.GetRandomBuyableOfGroupFromTech("Any", #TYPE, moduleSpaceID); } if (!entityPreset) { g_ConsoleMan.PrintString(std::string("WARNING: Could not find any ") + std::string(#TYPE) + std::string(" defined in a Group called \"") + groupName + std::string("\" in module ") + g_PresetMan.GetDataModuleName(moduleSpaceID) + "!"); return nullptr; } return dynamic_cast<TYPE *>(entityPreset->Clone()); } TYPE * LuaAdaptersEntityCreate::Random##TYPE(std::string groupName, std::string dataModuleName) { int moduleSpaceID = g_PresetMan.GetModuleID(dataModuleName); const Entity *entityPreset = g_PresetMan.GetRandomBuyableOfGroupFromTech(groupName, #TYPE, moduleSpaceID); if (!entityPreset) { entityPreset = g_PresetMan.GetRandomBuyableOfGroupFromTech(groupName, #TYPE, g_PresetMan.GetModuleID("Base.rte")); } if (!entityPreset) { entityPreset = g_PresetMan.GetRandomBuyableOfGroupFromTech("Any", #TYPE, moduleSpaceID); } if (!entityPreset) { g_ConsoleMan.PrintString(std::string("WARNING: Could not find any ") + std::string(#TYPE) + std::string(" defined in a Group called \"") + groupName + std::string("\" in module ") + dataModuleName + "!"); return nullptr; } return dynamic_cast<TYPE *>(entityPreset->Clone()); } TYPE * LuaAdaptersEntityCreate::Random##TYPE(std::string groupName) { return Random##TYPE(groupName, "All"); }
#define LuaEntityCloneFunctionDefinitionForType(TYPE) TYPE * LuaAdaptersEntityClone::Clone##TYPE(const TYPE *thisEntity) { if (thisEntity) { return dynamic_cast<TYPE *>(thisEntity->Clone()); } g_ConsoleMan.PrintString(std::string("ERROR: Tried to clone a ") + std::string(#TYPE) + std::string(" reference that is nil!")); return nullptr; }
#define LuaEntityCastFunctionsDefinitionsForType(TYPE) TYPE * LuaAdaptersEntityCast::To##TYPE(Entity *entity) { TYPE *targetType = dynamic_cast<TYPE *>(entity); if (!targetType) { g_ConsoleMan.PrintString(std::string("ERROR: Tried to convert a non-") + std::string(#TYPE) + std::string(" Entity reference to an ") + std::string(#TYPE) + std::string(" reference! Entity was ") + (entity ? entity->GetPresetName() : "nil")); } return targetType; } const TYPE * LuaAdaptersEntityCast::ToConst##TYPE(const Entity *entity) { const TYPE *targetType = dynamic_cast<const TYPE *>(entity); if (!targetType) { g_ConsoleMan.PrintString(std::string("ERROR: Tried to convert a non-") + std::string(#TYPE) + std::string(" Entity reference to an ") + std::string(#TYPE) + std::string(" reference! Entity was ") + (entity ? entity->GetPresetName() : "nil")); } return targetType; } bool LuaAdaptersEntityCast::Is##TYPE(Entity *entity) { return dynamic_cast<TYPE *>(entity) ? true : false; } SolObjectWrapper * LuaAdaptersEntityCast::ToSolObject##TYPE (Entity *entity, lua_State *luaState) { return new SolObjectWrapper(new luabind::object(luaState, dynamic_cast<TYPE *>(entity)), ""); } /* Bullshit semi-hack to automatically populate the Luabind Object cast function map that is used in LuaMan::RunScriptFunctionObject */ static const bool EntityToSolObjectCastMapAutoInserterForType##TYPE = []() { LuaAdaptersEntityCast::s_EntityToSolObjectCastFunctions.try_emplace(std::string(#TYPE), &LuaAdaptersEntityCast::ToSolObject##TYPE); return true; }()
#define LuaPropertyOwnershipSafetyFakerFunctionDefinition(OBJECTTYPE, PROPERTYTYPE, SETTERFUNCTION) void LuaAdaptersPropertyOwnershipSafetyFaker::OBJECTTYPE##SETTERFUNCTION(OBJECTTYPE *luaSelfObject, PROPERTYTYPE *objectToSet) { luaSelfObject->SETTERFUNCTION(objectToSet ? dynamic_cast<PROPERTYTYPE *>(objectToSet->Clone()) : nullptr); }