#pragma once

/// Header file for the AEmitter class.
/// @author Daniel Tabar
/// data@datarealms.com
/// http://www.datarealms.com
/// Inclusions of header files
#include "Attachable.h"
#include "Emission.h"

namespace RTE {

	/// An attachable MO that creates and emits particle MO's.
	class AEmitter : public Attachable {

		/// Public member variable, method and friend function declarations
	public:
		friend struct EntityLuaBindings;

		// Concrete allocation and cloning definitions
		EntityAllocation(AEmitter);
		SerializableOverrideMethods;
		ClassInfoGetters;

		/// Constructor method used to instantiate a AEmitter object in system
		/// memory. Create() should be called before using the object.
		AEmitter();

		/// Destructor method used to clean up a AEmitter object before deletion
		/// from system memory.
		~AEmitter() override;

		/// Creates a AEmitter to be identical to another, by deep copy.
		/// @param reference A reference to the AEmitter to deep copy.
		/// @return An error return value signaling sucess or any particular failure.
		/// Anything below 0 is an error signal.
		int Create(const AEmitter& reference);

		/// Resets the entire AEmitter, including its inherited members, to their
		/// default settings or values.
		void Reset() override {
			Clear();
			MOSRotating::Reset();
		}

		/// Destroys and resets (through Clear()) the SceneLayer object.
		/// @param notInherited Whether to only destroy the members defined in this derived class, or (default: false)
		/// to destroy all inherited members also.
		void Destroy(bool notInherited = false) override;

		/// Indicates whether this AEmitter is currently enabled and emitting.
		/// @return Whether it's emitting or not.
		bool IsEmitting() const { return m_EmitEnabled; }

		/// Returns whether this emitter was emitting last frame.
		/// @return Whether this emitter was emitting last frame.
		bool WasEmitting() const { return m_WasEmitting; }

		/// Reset the timers of all emissions so they will start/stop at the
		/// correct relative offsets from now.
		void ResetEmissionTimers();

		/// Sets this AEmitter to start emitting at the set rate, or to stop.
		/// @param enable Whether to enable or disable emission. (default: true)
		void EnableEmission(bool enable = true);

		/// Calculates the forces this emitter applies on any parent.
		/// @param burst Whether to calculate a burst update or not. (default: false)
		/// @return The approximate impulse generated by the emitter.
		float EstimateImpulse(bool burst = false);

		/// Gets the rate at which all of the Emissions of this AEmitter, combined, emit their particles.
		/// @return The combined particles per minute of all Emissions in this AEmitter.
		float GetTotalParticlesPerMinute() const;

		/// Gets the number of particles that will be emitted by all the Emissions of this AEmitter combined, in one shot when a burst is triggered.
		/// @return The combined burst size of all Emissions in this AEmitter.
		int GetTotalBurstSize() const;

		/// Gets the scale factor that will be applied to the regular spread and
		/// emission velocity to get the burst particle parameters.
		/// @return The scale factor.
		float GetBurstScale() const { return m_BurstScale; }

		/// Gets the angle of direction that the emitted particles will be shot at.
		/// @return A float with the angle in radians.
		float GetEmitAngle() const { return m_EmitAngle.GetRadAngle(); }

		const Matrix& GetEmitAngleMatrix() const { return m_EmitAngle; }

		/// Gets the offset of the emission point from this' sprite center, which gets rotated with this.
		/// @return The emission offset.
		Vector GetEmitOffset() const { return m_EmissionOffset; }

		/// Sets the offset of the emission point from this' sprite center, which gets rotated with this.
		/// @param newOffset The new emission offset.
		void SetEmitOffset(const Vector& newOffset) { m_EmissionOffset = newOffset; }

		/// A vector in the direction, including the rotation of the emitter, that
		/// the emitted particles will be shot at.
		/// @return A unit vector.
		Vector GetEmitVector() const { return Vector(1, 0).RadRotate(m_HFlipped ? c_PI + m_Rotation.GetRadAngle() - m_EmitAngle.GetRadAngle() : m_Rotation.GetRadAngle() + m_EmitAngle.GetRadAngle()); }

		/// A vector in the opposite direction, including the rotation of the
		/// emitter, that the emitted particles will be shot at.
		/// @return A unit vector.
		Vector GetRecoilVector() const { return Vector(-1, 0).RadRotate(m_HFlipped ? c_PI + m_Rotation.GetRadAngle() - m_EmitAngle.GetRadAngle() : m_Rotation.GetRadAngle() + m_EmitAngle.GetRadAngle()); }

		/// Gets the BurstSpacing for this emitter.
		/// @return The BurstSpacing in ms.
		float GetBurstSpacing() const { return m_BurstSpacing; }

		/*
		/// Gets the angle spread of velocity of the emitted MO's to each side of
		/// the angle of emission of this AEmitter.
		/// @return A float with the spread in r's. PI/2 would mean that MO's fly out to
		/// one side only, with the m_EmitAngle defining the middle of that half
		/// circle.
		    float GetEmitSpread() const { return m_Spread; }


		/// Gets the min end of the range the velocity of a particle being emitted
		/// by this AEmitter can have.
		/// @return A float with the min vel possible for an emitted particle.
		    float GetEmitVelMin() const { return m_MinVelocity; }


		/// Gets the max end of the range the velocity of a particle being emitted
		/// by this AEmitter can have.
		/// @return A float with the max vel possible for an emitted particle.
		    float GetEmitVelMax() const { return m_MaxVelocity; }
		*/

		/// Gets the normalized throttle scalar which controls how to affect the
		/// emission rate as per the emisison rate range. Depricated for Lua, use
		/// the Throttle property instead.
		/// @return A float with the normalized throttle scalar. 1.0 means max throttle,
		/// 0 means normal, -1.0 means least emission rate.
		float GetThrottle() const { return m_Throttle; }

		/// Gets the adjusted throttle multiplier that is factored into the emission rate of this AEmitter.
		/// @return The throttle strength as a multiplier.
		float GetThrottleFactor() const { return Lerp(-1.0f, 1.0f, m_NegativeThrottleMultiplier, m_PositiveThrottleMultiplier, m_Throttle); }

		/// Gets the throttle value that will achieve a given throttle factor that is factored into the emission rate of this AEmitter.
		/// @return The throttle value that will achieve the given throttle factor.
		float GetThrottleForThrottleFactor(float throttleFactor) const { return Lerp(m_NegativeThrottleMultiplier, m_PositiveThrottleMultiplier, -1.0f, 1.0f, throttleFactor); }

		/// Returns a scaled throttle value that represents a linear increase of force.
		/// Because of (bad) reasons, throttle is in the range -1.0F to 1.0F, where -1.0F is "minimum force" and 1.0F is "maximum force".
		/// 0.0F is "whoever the fuck knows?" force. As such, multiplying throttle by 2 does not mean twice the force emitted, instead it means "whoever the fuck knows?" additional force emitted.
		/// All work and no play makes Jack a dull boy. All work and no play makes Jack a dull boy. All work and no play makes Jack a dull boy.
		/// ...this helper function lets us apply a scale to throttle and get a sensible result.
		/// @param throttle The throttle value to be considered.
		/// @param multiplier The multiplier to scale by, in terms of absolute force emitted.
		/// @return Adjusted throttle value scaled by the multiplier value.
		float GetScaledThrottle(float throttle, float multiplier) const;

		/// Gets the negative throttle multiplier of this AEmitter.
		/// @return The negative throttle multiplier of this AEmitter.
		float GetNegativeThrottleMultiplier() const { return m_NegativeThrottleMultiplier; }

		/// Gets the positive throttle multiplier of this AEmitter.
		/// @return The positive throttle multiplier of this AEmitter.
		float GetPositiveThrottleMultiplier() const { return m_PositiveThrottleMultiplier; }

		/// Sets the negative throttle multiplier of this AEmitter.
		/// @param newValue The new throttle multiplier of this AEmitter.
		void SetNegativeThrottleMultiplier(float newValue) { m_NegativeThrottleMultiplier = newValue; }

		/// Sets the positive throttle multiplier of this AEmitter.
		/// @param newValue The new throttle multiplier of this AEmitter.
		void SetPositiveThrottleMultiplier(float newValue) { m_PositiveThrottleMultiplier = newValue; }

		/*
		/// Sets the rate at which this AEmitter emits its particles.
		/// @param rate A float with the rate in #/min.
		    void SetEmitRate(const float rate) { m_PPM = rate; }


		/// Sets the number of particles that will be emitted in one shot upon
		/// a triggered burst of this AEmitter.
		/// @param count The number of emitted particles a burst should have. 0 means burst
		/// are disabled.
		    void SetBurstCount(const int count) { m_BurstSize = count; }
		*/

		/// Sets the scale factor that will be applied to the regular spread and
		/// emission velocity to get the burst particle parameters.
		/// @param scale The scale factor.
		void SetBurstScale(const float scale) { m_BurstScale = scale; }

		/// Sets the BurstSpacing for this emitter.
		/// @param spacing The BurstSpacing in ms.
		void SetBurstSpacing(const float spacing) { m_BurstSpacing = spacing; }

		/// Gets the flash of this AEmitter.
		/// @return A pointer to the AEmitter's flash. Ownership is NOT transferred!
		Attachable* GetFlash() const { return m_pFlash; }

		/// Sets the flash for this AEmitter. Ownership IS transferred!
		/// @param newFlash The new flash to use.
		void SetFlash(Attachable* newFlash);

		/// Gets the display scale factor of the flash effect. This is purely
		/// visual.
		/// @return The scale factor of the flash draw.
		float GetFlashScale() const { return m_FlashScale; }

		/// Sets the display scale factor of the flash effect. This is purely
		/// visual.
		/// @param flashScale The scale factor of the flash draw. (default: 1.0f)
		void SetFlashScale(float flashScale = 1.0f) { m_FlashScale = flashScale; }

		/// Sets the angle of direction that the emitted particles will be shot at.
		/// @param m_EmitAngle.SetRadAngle(angle A float with the angle in radians.
		void SetEmitAngle(const float angle) { m_EmitAngle.SetRadAngle(angle); }

		/// Sets the normalized throttle scalar which controls how to affect the
		/// emission rate as per the emisison rate range.
		/// @param m_Throttle A float with the normalized throttle scalar. 1.0 means max throttle, (default: throttle > 1.0f ? 1.0f : (throttle < -1.0f ? -1.0f : throttle)
		/// 0 means normal, -1.0 means least emission rate.
		void SetThrottle(float throttle) { m_Throttle = throttle > 1.0f ? 1.0f : (throttle < -1.0f ? -1.0f : throttle); }

		/*
		/// Sets the angle spread of velocity of the emitted MO's to each side of
		/// angle of emission of this AEmitter.
		/// @param spread A float with the spread in r's. PI/2 would mean that MO's fly out to
		/// one side only, with the m_EmitAngle defining the middle of that half
		/// circle.
		    void SetEmitSpread(const float spread) { m_Spread = spread; }


		/// Sets the min end of the range the velocity of a particle being emitted
		/// by this AEmitter can have.
		/// @param minVel A float with the min vel possible for an emitted particle.
		    void SetEmitVelMin(const float minVel) { m_MinVelocity = minVel; }


		/// Sets the max end of the range the velocity of a particle being emitted
		/// by this AEmitter can have.
		/// @param maxVel A float with the max vel possible for an emitted particle.
		    void SetEmitVelMax(const float maxVel) { m_MaxVelocity = maxVel; }
		*/

		/// Triggers a one-shot burst of emissions in the number that has
		/// previously been set. The burst will happen during the next Update of
		/// this AEmitter.
		void TriggerBurst() { m_BurstTriggered = true; }

		/// Checks if it is possible to trigger a one-shot burst of emissions during
		/// the next Update of this AEmitter.
		/// @return If it is possible to trigger a burst.
		bool CanTriggerBurst() { return m_BurstSpacing <= 0 || m_BurstTimer.IsPastSimMS(m_BurstSpacing); }

		/// Indicates whether this AEmitter is set to burst next update or not.
		/// @return Whether a burst is gonna happen or not..
		bool IsSetToBurst() const { return m_BurstTriggered; }

		/// Registers a new AlarmEvent if this emitter has a loudness above zero.
		/// @param Team Team that will ignore this AlarmEvent.
		void AlarmOnEmit(int Team) const {
			if (m_LoudnessOnEmit > 0)
				g_MovableMan.RegisterAlarmEvent(AlarmEvent(m_Pos, Team, m_LoudnessOnEmit));
		}

		/// Resest all the timers used by this. Can be emitters, etc. This is to
		/// prevent backed up emissions to come out all at once while this has been
		/// held dormant in an inventory.
		void ResetAllTimers() override {
			Attachable::ResetAllTimers();
			m_BurstTimer.Reset();
			m_LastEmitTmr.Reset();
		}

		/// Updates this MovableObject. Supposed to be done every frame.
		void Update() override;

		/// Returns burst damage of this emitter.
		/// @return Burst damage of emitter.
		float GetBurstDamage() const { return m_BurstDamage * m_EmitterDamageMultiplier; }

		/// Sets burst damage of this emitter.
		/// @param newValue Burst damage of emitter.
		void SetBurstDamage(float newValue) { m_BurstDamage = newValue; }

		/// Returns emit damage of this emitter.
		/// @return Emit damage of emitter.
		float GetEmitDamage() const { return m_EmitDamage * m_EmitterDamageMultiplier; }

		/// Sets emit damage of this emitter.
		/// @param newValue Emit damage of emitter.
		void SetEmitDamage(float newValue) { m_EmitDamage = newValue; }

		/// Returns damage multiplier of this emitter.
		/// @return Damage multiplier of emitter.
		float GetEmitterDamageMultiplier() const { return m_EmitterDamageMultiplier; }

		/// Sets damage multiplier of this emitter.
		/// @param newValue New damage multiplier of emitter
		void SetEmitterDamageMultiplier(float newValue) { m_EmitterDamageMultiplier = newValue; }

		/// Draws this AEmitter's current graphical representation to a
		/// BITMAP of choice.
		/// @param pTargetBitmap A pointer to a BITMAP to draw on.
		/// @param targetPos The absolute position of the target bitmap's upper left corner in the Scene. (default: Vector())
		/// @param mode In which mode to draw in. See the DrawMode enumeration for the modes. (default: g_DrawColor)
		/// @param onlyPhysical Whether to not draw any extra 'ghost' items of this MovableObject, (default: false)
		/// indicator arrows or hovering HUD text and so on.
		void Draw(BITMAP* pTargetBitmap, const Vector& targetPos = Vector(), DrawMode mode = g_DrawColor, bool onlyPhysical = false) const override;

		/// Indicates whether this emitter deals damage.
		/// @return Returns true if this emitter deals damage.
		bool IsDamaging() { return (m_EmitDamage > 0 || m_BurstDamage > 0) && m_EmitterDamageMultiplier > 0; }

		/// Gets the number of emissions emitted since emission was last enabled.
		/// @return The number of emissions emitted since emission was last enabled.
		long GetEmitCount() const { return m_EmitCount; }

		/// Gets the number of emissions left before emitter is disabled.
		/// @return Returns the number of emissions left before emitter is disabled.
		long GetEmitCountLimit() const { return m_EmitCountLimit; }

		/// Sets the number of emissions left before emitter is disabled.
		/// @param newValue New number of emissions left
		void SetEmitCountLimit(long newValue) { m_EmitCountLimit = newValue; }

		/// Gets this AEmitter's emission sound. Ownership is NOT transferred!
		/// @return The SoundContainer for this AEmitter's emission sound.
		SoundContainer* GetEmissionSound() const { return m_EmissionSound; }

		/// Sets this AEmitter's emission sound. Ownership IS transferred!
		/// @param newSound The new SoundContainer for this AEmitter's emission sound.
		void SetEmissionSound(SoundContainer* newSound) { m_EmissionSound = newSound; }

		/// Gets this AEmitter's burst sound. Ownership is NOT transferred!
		/// @return The SoundContainer for this AEmitter's burst sound.
		SoundContainer* GetBurstSound() const { return m_BurstSound; }

		/// Sets this AEmitter's burst sound. Ownership IS transferred!
		/// @param newSound The new SoundContainer for this AEmitter's burst sound.
		void SetBurstSound(SoundContainer* newSound) { m_BurstSound = newSound; }

		/// Gets this AEmitter's end sound. Ownership is NOT transferred!
		/// @return The SoundContainer for this AEmitter's end sound.
		SoundContainer* GetEndSound() const { return m_EndSound; }

		/// Sets this AEmitter's end sound. Ownership IS transferred!
		/// @param newSound The new SoundContainer for this AEmitter's end sound.
		void SetEndSound(SoundContainer* newSound) { m_EndSound = newSound; }

		/// Returns whether this emitter just started emitting this frame.
		/// @return Whether this emitter just started emitting this frame.
		bool JustStartedEmitting() const { return !m_WasEmitting && m_EmitEnabled; }

		/// Protected member variable and method declarations
	protected:
		// Member variables
		static Entity::ClassInfo m_sClass;

		// The list of MO instances that get emitted
		std::vector<Emission> m_EmissionList;
		// Sounds
		SoundContainer* m_EmissionSound;
		SoundContainer* m_BurstSound;
		SoundContainer* m_EndSound;
		// Whether emitting is currently enabled or not.
		bool m_EmitEnabled;
		// Whether or not the it was emitting last frame or not.
		bool m_WasEmitting;
		// The number of emissions emitted since emission was last enabled
		long m_EmitCount;
		// The max number of emissions to emit per emit being enabled
		long m_EmitCountLimit;
		float m_NegativeThrottleMultiplier; //!< The multiplier applied to the emission rate when throttle is negative. Relative to the absolute throttle value.
		float m_PositiveThrottleMultiplier; //!< The multiplier applied to the emission rate when throttle is positive. Relative to the absolute throttle value.
		float m_Throttle; //!< The normalized throttle which controls the MSPE between 1.0 * m_MSPERange and -1.0 * m_MSPERange. 0 means emit the regular m_PPM amount.
		// Whether or not this' emissions ignore hits with itself, even if they are set to hit other MOs.
		bool m_EmissionsIgnoreThis;
		// The scale factor that will be applied to the regular spread and emission
		// velocity to get the the burst particle parameters.
		float m_BurstScale;
		// Damage dealt to the attached-to parent upon bursting.
		float m_BurstDamage;
		// Damage multiplier derived from penetrating particle. Affects both burst and emit damage values.
		float m_EmitterDamageMultiplier;
		// Indicates that a burst is set to happen during the next Update.
		bool m_BurstTriggered;
		// The shortest possible time between bursts, in ms
		float m_BurstSpacing;
		// Measures the shortest possible time between bursts
		Timer m_BurstTimer;
		// The angle of the direction the emitted particles will head in.
		// The m_Roataion of this AEmitter will be added to this angle.
		Matrix m_EmitAngle;
		// Offset of the emission point from this' sprite center, which gets rotated with this
		Vector m_EmissionOffset;
		// The amount of damage points that this emitter collects when emitting one non-burst particle.
		float m_EmitDamage;
		// Timer for timing how long ago the last particle was emitted. 0 means no limit.
		Timer m_LastEmitTmr;
		// Emission flash Attachable
		Attachable* m_pFlash;
		// Flash display scale
		float m_FlashScale;
		// How large impulse this emitter generates when bursting
		float m_AvgBurstImpulse;
		// How large impulse this emitter generates when firing
		float m_AvgImpulse;
		// How far this is audiable (in screens) when emitting as a jetpack or craft engine
		float m_LoudnessOnEmit;
		// Whether to only display flash on bursts, and not on any emission frame.
		bool m_FlashOnlyOnBurst;
		// Whether the burst sound should always play until completion, or whether it stops when this emitter stops emitting
		bool m_SustainBurstSound;
		// Whether the burst sound follows the emitter
		bool m_BurstSoundFollowsEmitter;

		/// Private member variable and method declarations
	private:
		/// Clears all the member variables of this AEmitter, effectively
		/// resetting the members of this abstraction level only.
		void Clear();

		// Disallow the use of some implicit methods.
		AEmitter(const AEmitter& reference) = delete;
		AEmitter& operator=(const AEmitter& rhs) = delete;
	};

} // namespace RTE
