#include "DataModule.h"
#include "ModuleMan.h"
#include "PresetMan.h"
#include "SceneMan.h"
#include "LuaMan.h"
#include "GameVersion.h"
#include "System.h"

#include <System/Semver200/semver200.h>

using namespace RTE;

const std::string DataModule::c_ClassName = "DataModule";

DataModule::DataModule() {
	Clear();
}

DataModule::DataModule(const std::string& moduleName, const ProgressCallback& progressCallback) {
	Clear();
	Create(moduleName, progressCallback);
}

DataModule::~DataModule() {
	Destroy();
}

void DataModule::Clear() {
	m_ModuleType = DataModuleType::Unofficial;
	m_FileName.clear();
	m_FriendlyName.clear();
	m_Author.clear();
	m_Description.clear();
	m_SupportedGameVersion = nullptr;
	m_Version = 1;
	m_ModuleID = -1;
	m_IconFile.Reset();
	m_Icon = nullptr;
	m_PresetList.clear();
	m_EntityList.clear();
	m_TypeMap.clear();
	m_MaterialMappings.fill(0);
	m_ScanFolderContents = false;
	m_IgnoreMissingItems = false;
	m_CrabToHumanSpawnRatio = 0;
	m_ScriptPath.clear();
	m_IsFaction = false;
	m_IsMerchant = false;
}

int DataModule::Create(const std::string& moduleName, const ProgressCallback& progressCallback) {
	m_FileName = std::filesystem::path(moduleName).generic_string();
	m_CrabToHumanSpawnRatio = 0;

	// Report that we're starting to read a new DataModule
	if (progressCallback) {
		progressCallback(m_FileName + " " + static_cast<char>(-43) + " loading:", true);
	}

	Reader reader;
	std::string indexPath = g_ModuleMan.GetFullModulePath(m_FileName + "/Index.ini");
	std::string mergedIndexPath = g_ModuleMan.GetFullModulePath(m_FileName + "/MergedIndex.ini");

	// NOTE: This looks for the MergedIndex.ini generated by the index merger tool. The tool is mostly superseded by disabling loading visuals, but still provides some benefit.
	if (std::filesystem::exists(mergedIndexPath)) {
		indexPath = mergedIndexPath;
	}

	// If the module is a mod, read only its `index.ini` to validate its SupportedGameVersion.
	if (m_ModuleType == DataModuleType::Unofficial && ReadModuleProperties(moduleName, progressCallback) >= 0) {
		CheckSupportedGameVersion();
	}

	if (reader.Create(indexPath, true, progressCallback) >= 0) {
		int result = Serializable::Create(reader);

		// Print an empty line to separate the end of a module from the beginning of the next one in the loading progress log.
		if (progressCallback) {
			progressCallback(" ", true);
		}

		if (m_ScanFolderContents) {
			result = FindAndRead(progressCallback);
		}

		return result;
	}
	return -1;
}

void DataModule::Destroy() {
	for (const PresetEntry& preset: m_PresetList) {
		delete preset.m_EntityPreset;
	}
	delete m_SupportedGameVersion;
	Clear();
}

int DataModule::ReadModuleProperties(const std::string& moduleName, const ProgressCallback& progressCallback) {
	m_FileName = moduleName;
	m_CrabToHumanSpawnRatio = 0;

	// Report that we're starting to read a new DataModule
	if (progressCallback) {
		progressCallback(m_FileName + " " + static_cast<char>(-43) + " reading properties:", true);
	}
	Reader reader;
	std::string indexPath(m_FileName + "/Index.ini");

	if (reader.Create(indexPath, true, progressCallback) >= 0) {
		reader.SetSkipIncludes(true);
		int result = Serializable::Create(reader);
		return result;
	}
	return -1;
}

int DataModule::ReadProperty(const std::string_view& propName, Reader& reader) {
	StartPropertyList(if (!g_PresetMan.GetEntityPreset(reader)) { reader.ReportError("Could not understand Preset type!"); })

	    MatchProperty("ModuleName", { reader >> m_FriendlyName; });
	MatchProperty("Author", { reader >> m_Author; });
	MatchProperty("Description", {
		std::string descriptionValue = reader.ReadPropValue();
		if (descriptionValue == "MultiLineText") {
			m_Description.clear();
			while (reader.NextProperty() && reader.ReadPropName() == "AddLine") {
				m_Description += reader.ReadPropValue() + "\n\n";
			}
			if (!m_Description.empty()) {
				m_Description.resize(m_Description.size() - 2);
			}
		} else {
			m_Description = descriptionValue;
		}
	});
	MatchProperty("IsFaction", {
		reader >> m_IsFaction;
		if (m_IsMerchant) {
			m_IsFaction = false;
		}
	});
	MatchProperty("IsMerchant", {
		reader >> m_IsMerchant;
		if (m_IsMerchant) {
			m_IsFaction = false;
		}
	});
	MatchProperty("SupportedGameVersion", {
		std::string versionText;
		reader >> versionText;
		// TODO: Need to proceed reading the includes after ReadModuleProperties so we don't read the properties again when fully creating.
		if (!m_SupportedGameVersion) {
			try {
				m_SupportedGameVersion = new version::Semver200_version(versionText);
			} catch (version::Parse_error&) {
				reader.ReportError("Couldn't parse the supported game version from the value provided: \"" + versionText + "\"!\nThe supported game version must be a valid semantic version number.\n");
			}
		}
	});
	MatchProperty("Version", { reader >> m_Version; });
	MatchProperty("ScanFolderContents", { reader >> m_ScanFolderContents; });
	MatchProperty("IgnoreMissingItems", { reader >> m_IgnoreMissingItems; });
	MatchProperty("CrabToHumanSpawnRatio", { reader >> m_CrabToHumanSpawnRatio; });
	MatchProperty("ScriptPath", {
		reader >> m_ScriptPath;
		LoadScripts();
	});
	MatchProperty("Require", {
		// Check for required dependencies if we're not load properties
		std::string requiredModule;
		reader >> requiredModule;
		if (!reader.GetSkipIncludes() && g_ModuleMan.GetModuleID(requiredModule) == -1) {
			reader.ReportError("\"" + m_FileName + "\" requires \"" + requiredModule + "\" in order to load!\n");
		}
	});
	MatchProperty("IconFile", {
		reader >> m_IconFile;
		m_Icon = m_IconFile.GetAsBitmap();
	});
	MatchProperty("FactionBuyMenuTheme", {
		if (reader.ReadPropValue() == "BuyMenuTheme") {
			while (reader.NextProperty()) {
				std::string themePropName = reader.ReadPropName();
				if (themePropName == "SkinFile") {
					m_BuyMenuTheme.SkinFilePath = reader.ReadPropValue();
				} else if (themePropName == "BannerFile") {
					m_BuyMenuTheme.BannerImagePath = reader.ReadPropValue();
				} else if (themePropName == "LogoFile") {
					m_BuyMenuTheme.LogoImagePath = reader.ReadPropValue();
				} else if (themePropName == "BackgroundColorIndex") {
					m_BuyMenuTheme.BackgroundColorIndex = std::clamp(std::stoi(reader.ReadPropValue()), 0, 255);
				} else {
					break;
				}
			}
		}
	});
	MatchProperty("AddMaterial", { return g_SceneMan.ReadProperty(propName, reader); });

	EndPropertyList;
}

int DataModule::Save(Writer& writer) const {
	Serializable::Save(writer);

	writer.NewPropertyWithValue("ModuleName", m_FriendlyName);

	if (!IsUserdata()) {
		writer.NewPropertyWithValue("Author", m_Author);
		writer.NewPropertyWithValue("Description", m_Description);
		writer.NewPropertyWithValue("IsFaction", m_IsFaction);
		writer.NewPropertyWithValue("SupportedGameVersion", m_SupportedGameVersion->str());
		writer.NewPropertyWithValue("Version", m_Version);
		writer.NewPropertyWithValue("IconFile", m_IconFile);

		// TODO: Write out all the different entity instances, each having their own relative location within the data module stored
		// Will need the writer to be able to open different files and append to them as needed, probably done in NewEntity()
		// writer.NewEntity()
	} else {
		writer.NewPropertyWithValue("ScanFolderContents", m_ScanFolderContents);
		writer.NewPropertyWithValue("IgnoreMissingItems", m_IgnoreMissingItems);
	}

	return 0;
}

std::string DataModule::GetEntityDataLocation(const std::string& exactType, const std::string& instance) {
	const Entity* foundEntity = GetEntityPreset(exactType, instance);
	if (foundEntity == nullptr) {
		return "";
	}

	// Search for entity in instanceList
	for (const PresetEntry& presetListEntry: m_PresetList) {
		if (presetListEntry.m_EntityPreset == foundEntity) {
			return presetListEntry.m_FileReadFrom;
		}
	}

	RTEAbort("Tried to find allegedly existing Entity Preset Entry: " + foundEntity->GetPresetName() + ", but couldn't!");
	return "";
}

const Entity* DataModule::GetEntityPreset(const std::string& exactType, const std::string& instance) {
	if (exactType.empty() || instance == "None" || instance.empty()) {
		return nullptr;
	}
	if (auto classItr = m_TypeMap.find(exactType); classItr != m_TypeMap.end()) {
		// Find an instance of that EXACT type and name; derived types are not matched
		for (const auto& [instanceName, entity]: classItr->second) {
			if (instanceName == instance && entity->GetClassName() == exactType) {
				return entity;
			}
		}
	}
	return nullptr;
}

bool DataModule::AddEntityPreset(Entity* entityToAdd, bool overwriteSame, const std::string& readFromFile) {
	// Fail if the entity is unnamed or it's not the original preset.
	// TODO If we're overwriting, we may not want to fail if it's not the original preset, this needs to be investigated
	if (entityToAdd->GetPresetName() == "None" || entityToAdd->GetPresetName().empty() || !entityToAdd->IsOriginalPreset()) {
		return false;
	}
	bool entityAdded = false;

	if (Entity* existingEntity = GetEntityIfExactType(entityToAdd->GetClassName(), entityToAdd->GetPresetName())) {
		// If we're commanded to overwrite any collisions, then do so by cloning over the existing instance in the list
		// This way we're not invalidating any instance references that would have been taken out and held by clients
		if (overwriteSame) {
			entityToAdd->SetModuleID(m_ModuleID); // TODO this is probably overwritten by Entity::Create(other), making it useless. Double-check this and remove this line if certain
			entityToAdd->Clone(existingEntity);
			// Make sure the existing one is still marked as the Original Preset
			existingEntity->m_IsOriginalPreset = true;
			// Alter the instance entry to reflect the data file location of the new definition
			if (readFromFile != "Same") {
				std::list<PresetEntry>::iterator itr = m_PresetList.begin();
				for (; itr != m_PresetList.end(); ++itr) {
					// When we find the correct entry, alter its data file location
					if ((*itr).m_EntityPreset == existingEntity) {
						(*itr).m_FileReadFrom = readFromFile;
						break;
					}
				}
				RTEAssert(itr != m_PresetList.end(), "Tried to alter allegedly existing Entity Preset Entry: " + entityToAdd->GetPresetName() + ", but couldn't find it in the list!");
			}
			return true;
		} else {
			return false;
		}
	} else {
		entityToAdd->SetModuleID(m_ModuleID);
		Entity* entityClone = entityToAdd->Clone();
		// Mark the one we are about to add to the list as the Original now - this is now the actual Original Preset instance
		entityClone->m_IsOriginalPreset = true;

		if (readFromFile == "Same" && m_PresetList.empty()) {
			RTEAbort("Tried to add first entity instance to data module " + m_FileName + " without specifying a data file!");
		}

		m_PresetList.push_back(PresetEntry(entityClone, readFromFile != "Same" ? readFromFile : m_PresetList.back().m_FileReadFrom));
		m_EntityList.push_back(entityClone);
		entityAdded = AddToTypeMap(entityClone);
		RTEAssert(entityAdded, "Unexpected problem while adding Entity instance \"" + entityToAdd->GetPresetName() + "\" to the type map of data module: " + m_FileName);
	}
	return entityAdded;
}

bool DataModule::GetGroupsWithType(std::list<std::string>& groupList, const std::string& withType) {
	bool foundAny = false;

	if (withType == "All" || withType.empty()) {
		for (const std::string& groupRegisterEntry: m_GroupRegister) {
			groupList.push_back(groupRegisterEntry);
			// TODO: it seems weird that foundAny isn't set to true here, given that the list gets filled.
			// But I suppose no actual finding is done. Investigate this and see where it's called, maybe this should be changed
		}
	} else {
		if (auto classItr = m_TypeMap.find(withType); classItr != m_TypeMap.end()) {
			const std::unordered_set<std::string>* groupListPtr = nullptr;
			// Go through all the entities of that type, adding the groups they belong to
			for (const auto& [instanceName, entity]: classItr->second) {
				groupListPtr = entity->GetGroups();

				for (const std::string& groupListEntry: *groupListPtr) {
					groupList.push_back(groupListEntry); // Get the grouped entities, without transferring ownership
					foundAny = true;
				}
			}

			// Make sure there are no dupe groups in the list
			groupList.sort();
			groupList.unique();
		}
	}
	return foundAny;
}

bool DataModule::GetAllOfOrNotOfGroups(std::list<Entity*>& entityList, const std::string& type, const std::vector<std::string>& groups, bool excludeGroups) {
	if (groups.empty()) {
		return false;
	}
	bool foundAny = false;

	// Find either the Entity typelist that contains all entities in this DataModule, or the specific class' typelist (which will get all derived classes too).
	if (auto classItr = m_TypeMap.find((type.empty() || type == "All") ? "Entity" : type); classItr != m_TypeMap.end()) {
		RTEAssert(!classItr->second.empty(), "DataModule has class entry without instances in its map!?");

		for (const auto& [instanceName, entity]: classItr->second) {
			if (excludeGroups) {
				bool excludeEntity = false;
				for (const std::string& group: groups) {
					if (entity->IsInGroup(group)) {
						excludeEntity = true;
						break;
					}
				}
				if (!excludeEntity) {
					entityList.emplace_back(entity);
					foundAny = true;
				}
			} else {
				for (const std::string& group: groups) {
					if (entity->IsInGroup(group)) {
						entityList.emplace_back(entity);
						foundAny = true;
						break;
					}
				}
			}
		}
	}
	return foundAny;
}

bool DataModule::GetAllOfType(std::list<Entity*>& entityList, const std::string& type) {
	if (type.empty()) {
		return false;
	}

	if (auto classItr = m_TypeMap.find(type); classItr != m_TypeMap.end()) {
		RTEAssert(!classItr->second.empty(), "DataModule has class entry without instances in its map!?");

		for (const auto& [instanceName, entity]: classItr->second) {
			entityList.push_back(entity); // Get the entities, without transferring ownership
		}
		return true;
	}
	return false;
}

bool DataModule::AddMaterialMapping(unsigned char fromID, unsigned char toID) {
	RTEAssert(fromID > 0 && fromID < c_PaletteEntriesNumber && toID > 0 && toID < c_PaletteEntriesNumber, "Tried to make an out-of-bounds Material mapping");

	bool clear = m_MaterialMappings.at(fromID) == 0;
	m_MaterialMappings.at(fromID) = toID;

	return clear;
}

int DataModule::LoadScripts() const {
	if (m_ScriptPath.empty()) {
		return 0;
	}

	g_LuaMan.GetMasterScriptState().RunScriptFile(m_ScriptPath);
	for (LuaStateWrapper& luaState: g_LuaMan.GetThreadedScriptStates()) {
		luaState.RunScriptFile(m_ScriptPath);
	}

	return 0;
}

void DataModule::ReloadAllScripts() const {
	for (const PresetEntry& presetListEntry: m_PresetList) {
		presetListEntry.m_EntityPreset->ReloadScripts();
	}
	LoadScripts();
}

int DataModule::FindAndRead(const ProgressCallback& progressCallback) {
	int result = 0;
	const std::string directoryToScan = g_ModuleMan.GetFullModulePath(m_FileName);
	for (const std::filesystem::directory_entry& directoryEntry: std::filesystem::directory_iterator(System::GetWorkingDirectory() + directoryToScan)) {
		if (directoryEntry.path().extension() == ".ini" && directoryEntry.path().filename() != "Index.ini") {
			Reader iniReader;
			if (iniReader.Create(directoryToScan + "/" + directoryEntry.path().filename().generic_string(), false, progressCallback) >= 0) {
				result = Serializable::CreateSerializable(iniReader, false, true, true);
				if (progressCallback) {
					progressCallback(" ", true);
				}
			}
		}
	}
	return result;
}

// TODO: This method is almost identical to GetEntityPreset, except it doesn't return a const Entity *.
// Investigate if the latter needs to return const (based on what's using it) and if not, get rid of this and replace its uses. At the very least, consider renaming this
// See https://github.com/cortex-command-community/Cortex-Command-Community-Project-Source/issues/87
Entity* DataModule::GetEntityIfExactType(const std::string& exactType, const std::string& presetName) {
	if (exactType.empty() || presetName == "None" || presetName.empty()) {
		return nullptr;
	}
	if (auto classItr = m_TypeMap.find(exactType); classItr != m_TypeMap.end()) {
		// Find an instance of that EXACT type and name; derived types are not matched
		for (const auto& [instanceName, entity]: classItr->second) {
			if (instanceName == presetName && entity->GetClassName() == exactType) {
				return entity;
			}
		}
	}
	return nullptr;
}

bool DataModule::AddToTypeMap(Entity* entityToAdd) {
	if (!entityToAdd || entityToAdd->GetPresetName() == "None" || entityToAdd->GetPresetName().empty()) {
		return false;
	}

	// Walk up the class hierarchy till we reach the top, adding an entry of the passed in entity into each typelist as we go along
	for (const Entity::ClassInfo* pClass = &(entityToAdd->GetClass()); pClass != nullptr; pClass = pClass->GetParent()) {
		auto classItr = m_TypeMap.find(pClass->GetName());

		// No instances of this entity have been added yet so add a class category for it
		if (classItr == m_TypeMap.end()) {
			classItr = (m_TypeMap.insert(std::pair<std::string, std::list<std::pair<std::string, Entity*>>>(pClass->GetName(), std::list<std::pair<std::string, Entity*>>()))).first;
		}

		// NOTE We're adding the entity to the class category list but not transferring ownership. Also, we're not checking for collisions as they're assumed to have been checked for already
		(*classItr).second.push_back(std::pair<std::string, Entity*>(entityToAdd->GetPresetName(), entityToAdd));
	}
	return true;
}

void DataModule::CheckSupportedGameVersion() const {
	if (*m_SupportedGameVersion == c_GameVersion) {
		return;
	}

	static const std::string contactAuthor = "Please contact the mod author or ask for help in the CCCP discord server.";

	RTEAssert(m_SupportedGameVersion, m_FileName + " does not specify a supported Cortex Command version, so it is not compatible with this version of Cortex Command (" + c_GameVersion.str() + ").\n\n" + contactAuthor);

	bool modulePrereleaseVersionMismatch = !m_SupportedGameVersion->prerelease().empty();
	bool moduleBuildVersionMismatch = !m_SupportedGameVersion->build().empty();
	RTEAssert(!modulePrereleaseVersionMismatch && !moduleBuildVersionMismatch, m_FileName + " was developed for pre-release build of Cortex Command v" + m_SupportedGameVersion->str() + ", this game version (v" + c_GameVersion.str() + ") is incompatible.\n\nMods developed on a pre-release must match the game version exactly.\n" + contactAuthor);

	bool gamePrereleaseVersionMismatch = !c_GameVersion.prerelease().empty();
	bool gameBuildVersionMismatch = !c_GameVersion.build().empty();
	RTEAssert(!gamePrereleaseVersionMismatch && !gameBuildVersionMismatch, m_FileName + " was developed for Cortex Command v" + m_SupportedGameVersion->str() + ", this pre-release version of the game (v" + c_GameVersion.str() + ") may not support it.\n\nMods must match the game version exactly to use pre-release builds.\n" + contactAuthor);

	// Game engine is the same major version as the Module
	bool majorVersionMatch = c_GameVersion.major() == m_SupportedGameVersion->major();
	// Game engine is at least the minor version the Module requires (allow patch mismatch)
	bool minorVersionInRange = m_SupportedGameVersion->inc_minor() <= c_GameVersion.inc_minor();

	RTEAssert(majorVersionMatch && minorVersionInRange, m_FileName + " was developed for Cortex Command v" + m_SupportedGameVersion->str() + ", so this version of Cortex Command (v" + c_GameVersion.str() + ") may not support it.\n" + contactAuthor);
}
